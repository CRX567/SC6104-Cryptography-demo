# Pollard’s Rho 哈希碰撞算法实现（Go 语言）

## 一、项目简介

本项目实现了 Pollard’s Rho 哈希碰撞算法，用于在截断后的 SHA-256 哈希空间中寻找碰撞。
算法核心思想是通过函数迭代与循环检测，在有限空间中找到两个不同输入，使它们的截断哈希值相同(找到**碰撞**)。
该算法能在保持时间复杂度不变的前提下，将空间复杂度从指数级降低为常数级.

---

## 二、研究背景与理论基础

### 1. 哈希函数与碰撞问题

哈希函数是一种将任意长度的输入映射为固定长度输出的单向函数：

```
h : {0,1}* → {0,1}^m
```

如果存在两个不同的输入满足：

```
h(x1) = h(x2)
```

就称这两个输入发生了哈希碰撞（Collision）。

对于输出为 m 位的理想随机哈希函数，碰撞期望计算次数大约为：

```
2^(m/2)
```

这就是著名的“生日悖论”结果。

---

### 2. 传统方法：生日攻击的局限

生日攻击通过随机生成大量输入并保存其哈希值到哈希表中，然后检测是否出现重复。
其时间复杂度约为 O(2^(m/2))，但需要存储同样规模的哈希表，空间复杂度也是 O(2^(m/2))。
当 m 较大时，这种方法所需内存量巨大，难以实现。

---

### 3. Pollard’s Rho 算法的核心思想

Pollard’s Rho 算法提出了一种不需要保存大量哈希值的方法。
它基于以下事实：

> 在一个有限集合中不断迭代一个确定性函数，最终必然出现重复（循环）（**鸽笼原理**，即当应用函数的次数N > 集合空间m时，再次应用该函数一定会与先前的值重复）。

因此我们定义一个迭代函数：

```
f(x) = Trunc_m(SHA256(x))
```

从随机种子 x0 开始生成序列：

```
x1 = f(x0)
x2 = f(x1)
x3 = f(x2)
...
```

由于状态空间大小为 2^m，当迭代次数超过空间大小时，序列中必定出现重复的状态。
这一过程的形状类似希腊字母“ρ（Rho）”，因此得名 Pollard’s Rho。

当发现重复状态 xi = xj (i ≠ j) 时，意味着哈希输出出现碰撞。

---

### 4. 截断的作用（Truncation）

SHA-256 输出为 256 位，空间过大，无法在有限时间内完成实验。
因此我们只保留前 m 位作为状态空间，使得实验可以在合理时间完成。

截断后的哈希函数仍然保持随机分布特性，但搜索空间从 2^256 缩小为 2^m，
从而可以通过有限次数的迭代找到循环。

例如：

| 截断位数 m | 状态空间大小 | 期望碰撞步数（约） |
|-------------|---------------|--------------------|
| 16 | 65,536 | 256 |
| 20 | 1,048,576 | 1,024 |
| 24 | 16,777,216 | 4,096 |
| 28 | 268,435,456 | 16,384 |

---

## 三、算法原理与流程

1. **定义迭代函数：** 使用 f(x) = Trunc_m(SHA256(x))，保证输出为 m 位。
2. **生成序列：** 从随机种子 x0 出发，依次计算 x1, x2, x3 …
3. **循环检测：** 当空间有限时，序列必然进入循环。使用 Brent 算法检测循环。
4. **计算循环参数：** 检测到相遇后，计算 μ（循环起点）与 λ（循环长度）。
5. **恢复碰撞输入：** 再次遍历前 μ + λ 步，找到产生相同截断哈希的两条不同输入。

---

## 四、循环检测算法：Brent 方法

Brent 算法是一种高效的循环检测方式，比传统的“龟兔赛跑”法调用函数更少。

**算法逻辑：**
1. 设定两个指针：tortoise（慢）与 hare（快）。
2. hare 每次迭代一位，同时计数。
3. 每当迭代次数达到某个幂次（如 2, 4, 8, 16…）时，令 tortoise 追上 hare。
4. 若 tortoise == hare，说明出现循环。
5. 计算循环长度 λ；
6. 再次迭代计算循环起点 μ。

该方法只需常数级空间 O(1)，效率高，易于在哈希函数中实现。

---

## 五、Go 语言实现逻辑

### 1. 主体思路

- 使用 Go 的 crypto/sha256 计算哈希；
- 对哈希结果进行位截断（取前 m 位）；
- 使用 Brent 算法检测循环；
- 找到循环后，重放序列并查找重复哈希值以确认碰撞。

### 2. 核心函数设计

| 函数名 | 功能 |
|--------|------|
| truncHash(data, m) | 计算 SHA-256 并截断前 m 位 |
| fIter(state, m) | 迭代函数 f(x) |
| brentCycleFinding(seed, m) | 检测循环并返回 (mu, lambda) |
| recoverCollision(seed, m, mu, lam) | 重放序列并恢复碰撞输入 |
| main() | 程序入口，执行完整流程并打印结果 |

### 3. 截断实现细节

由于 SHA-256 输出 256 位（32 字节），截断过程如下：

```go
byteLen := (m + 7) / 8
hash := sha256.Sum256(data)
trunc := hash[:byteLen]
mask := byte(0xFF) >> (byteLen*8 - m)
trunc[0] &= mask
return trunc
```

这样可以保证返回值长度固定且严格保留 m 位有效比特。

---

## 六、运行示例

假设 m = 20（搜索空间为 2^20 ≈ 1,048,576）：

```
=== Pollard’s Rho 哈希碰撞实验 ===
截断位数：20 bits
循环检测完成：mu = 942, lambda = 1033
找到碰撞！
输入1：0b4539
输入2：0e329a
截断哈希：0a129a
运行步数 ≈ 5700
```

结果表明，算法在约 2^(m/2) 次迭代内找到了碰撞，符合理论预期。

---

## 七、复杂度分析

| 指标 | 生日攻击 | Pollard’s Rho |
|------|-----------|----------------|
| 时间复杂度 | O(2^(m/2)) | O(1.25×2^(m/2)) |
| 空间复杂度 | O(2^(m/2)) | O(1) |
| 是否保存全部哈希值 | 是 | 否 |
| 是否适合大规模实现 | 否 | 是 |

Pollard’s Rho 用时间换空间，是在有限资源下寻找哈希碰撞的更高效方案。

---

Pollard’s Rho 算法是一种基于循环检测的哈希碰撞搜索方法。
它不依赖大量存储，而是利用函数迭代的必然循环特性，
在常数空间内实现与生日攻击相同级别的碰撞效率，
是理解密码学哈希函数特性的重要实验工具。
