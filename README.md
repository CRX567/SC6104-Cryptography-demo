# SC6104-Cryptography-demo
SC6104 homework
# Pollard’s Rho 哈希碰撞算法实现（Go 语言）



---

## 一、项目简介

本项目实现了 **Pollard’s Rho 哈希碰撞算法（Pollard’s Rho for Hash Collision）**，  
通过函数迭代与循环检测，在截断后的 SHA-256 哈希空间中寻找两个不同输入，使它们的哈希结果相同（即“碰撞”）。

该算法相比传统的 **生日攻击（Birthday Attack）**：
- 时间复杂度相同，为 \( O(2^{m/2}) \)；
- 但空间复杂度大幅下降，仅需常数级 \( O(1) \)。

---

## 二、算法原理说明

### 1. 哈希碰撞问题

给定哈希函数 \( h(x) \)，我们希望找到：
\[
x_1 \neq x_2 \quad 且 \quad h(x_1) = h(x_2)
\]

当哈希输出为 \( m \) 位时，输出空间大小为 \( N = 2^m \)。  
理论上，在理想的随机哈希中，需要 \( O(2^{m/2}) \) 次尝试才能出现碰撞。

---

### 2️. 传统方法的局限：生日攻击

生日攻击的思想是：
- 随机生成许多输入；
- 保存所有哈希值；
- 查找是否有重复项。

虽然效率高，但**需要巨大的内存**来保存哈希表（空间复杂度 \( O(2^{m/2}) \)）。  
因此无法扩展到较大的 m 值。

---

### 3. Pollard’s Rho 思想：有限空间中的循环

Pollard’s Rho 算法的核心思想是：
> 在有限集合中不断迭代一个函数，  
> 因为空间有限，序列最终必然进入循环。  
> 通过检测循环，即可找到哈希碰撞。

定义迭代函数：
\[
f(x) = \text{Trunc}_m(\text{SHA-256}(x))
\]

从随机初始点 \( x_0 \) 开始：
\[
x_1 = f(x_0), \quad x_2 = f(x_1), \quad x_3 = f(x_2), \dots
\]

由于输出空间有限（大小为 \( 2^m \)），  
根据鸽巢原理，序列 \( x_0, x_1, ... \) 必然出现重复。

当出现 \( x_i = x_j \)（i ≠ j）时，说明循环形成。  
这一结构类似希腊字母 “ρ（Rho）”，因此算法得名 **Pollard’s Rho**。

